BNF for xpath-grammar.jj

NON-TERMINALS
XPath2 			::= 	XPath <EOF>
MatchPattern 	::= 	Pattern <EOF>
XPath 			::= 	( ExprSequence )?
ExprSequence 	::= 	Expr ( <Comma> Expr )*
Pattern 		::= 	PathPattern ( ( <Union> | <Vbar> ) Pattern )?
PathPattern 	::= 	( ( <Root> ( RelativePathPattern )? ) | ( <RootDescendants> RelativePathPattern ) | ( IdKeyPattern ( ( <Slash> | <SlashSlash> ) RelativePathPattern )? ) | RelativePathPattern )
RelativePathPattern 	::= 	PatternStep ( ( <Slash> | <SlashSlash> ) RelativePathPattern )?
PatternStep 	::= 	( PatternAxis )? NodeTest Predicates
PatternAxis 	::= 	( <AxisChild> | <AxisAttribute> | <At> )
IdKeyPattern 	::= 	<QNameLpar> IdKeyValue ( <Comma> IdKeyValue )? <Rpar>
IdKeyValue 		::= 	( Literal | ( <VariableIndicator> <VarName> ) )
Expr 			::= 	OrExpr
OrExpr 			::= 	AndExpr ( <Or> AndExpr )*
AndExpr 		::= 	FLWRExpr ( <And> FLWRExpr )*
FLWRExpr 		::= 	( SimpleForClause <Return> )* QuantifiedExpr
QuantifiedExpr 	::= 	( ( <Some> | <Every> ) <VarName> <In> Expr ( <Comma> ( <VariableIndicator> <VarName> ) <In> Expr )* <Satisfies> )* IfExpr
IfExpr 			::= 	( <IfLpar> Expr <Rpar> <Then> Expr <Else> )* InstanceofExpr
InstanceofExpr 	::= 	CastableExpr ( <Instanceof> SequenceType )?
CastableExpr 	::= 	ComparisonExpr ( <Castable> SingleType )?
ComparisonExpr 	::= 	RangeExpr ( ( ValueComp | GeneralComp | NodeComp | OrderComp ) RangeExpr )?
RangeExpr 		::= 	AdditiveExpr ( <To> AdditiveExpr )?
AdditiveExpr 	::= 	MultiplicativeExpr ( ( <Plus> | <Minus> ) MultiplicativeExpr )*
MultiplicativeExpr 	::= 	UnaryExpr ( ( <Multiply> | <Div> | <Idiv> | <Mod> ) UnaryExpr )*
UnaryExpr 		::= 	( <Minus> | <Plus> )* UnionExpr
UnionExpr 		::= 	IntersectExceptExpr ( ( <Union> | <Vbar> ) IntersectExceptExpr )*
IntersectExceptExpr 	::= 	ValueExpr ( ( <Intersect> | <Except> ) ValueExpr )*
ValueExpr 		::= 	( ValidateExpr | CastExpr | TreatExpr | PathExpr )
PathExpr 		::= 	( ( <Root> ( RelativePathExpr )? ) | ( <RootDescendants> RelativePathExpr ) | RelativePathExpr )
RelativePathExpr 	::= 	StepExpr ( ( <Slash> | <SlashSlash> ) StepExpr )*
StepExpr 		::= 	( ForwardStep | ReverseStep | PrimaryExpr ) Predicates
SimpleForClause ::= 	<ForVariable> <VarName> <In> Expr ( <Comma> ( <VariableIndicator> <VarName> ) <In> Expr )*
ValidateExpr 	::= 	( <ValidateLbrace> | ( <ValidateContext> SchemaGlobalContext ( <Slash> SchemaContextStep )* <LbraceExprEnclosure> ) ) Expr <Rbrace>
CastExpr 		::= 	( <CastAs> SingleType ) ParenthesizedExpr
TreatExpr 		::= 	( <TreatAs> SequenceType ) ParenthesizedExpr
GeneralComp 	::= 	( <Equals> | <NotEquals> | <Lt> | <LtEquals> | <Gt> | <GtEquals> )
ValueComp 		::= 	( <FortranEq> | <FortranNe> | <FortranLt> | <FortranLe> | <FortranGt> | <FortranGe> )
NodeComp 		::= 	( <Is> | <IsNot> )
OrderComp 		::= 	( <LtLt> | <GtGt> )
PrimaryExpr 	::= 	( Literal | FunctionCall | ( <VariableIndicator> <VarName> ) | ParenthesizedExpr )
ForwardAxis 	::= 	( <AxisChild> | <AxisDescendant> | <AxisAttribute> | <AxisSelf> | <AxisDescendantOrSelf> | <AxisFollowingSibling> | <AxisFollowing> | <AxisNamespace> )
ReverseAxis 	::= 	( <AxisParent> | <AxisAncestor> | <AxisPrecedingSibling> | <AxisPreceding> | <AxisAncestorOrSelf> )
NodeTest 		::= 	( KindTest | NameTest )
NameTest 		::= 	( <QName> | Wildcard )
Wildcard 		::= 	( <Star> | <NCNameColonStar> | <StarColonNCName> )
KindTest 		::= 	( ProcessingInstructionTest | CommentTest | TextTest | AnyKindTest )
ProcessingInstructionTest 	::= 	<ProcessingInstructionLpar> ( <StringLiteral> )? <Rpar>
CommentTest 	::= 	<CommentLpar> <Rpar>
TextTest 		::= 	<TextLpar> <Rpar>
AnyKindTest 	::= 	<NodeLpar> <Rpar>
ForwardStep 	::= 	( ( ForwardAxis ( NodeTest ) ) | AbbreviatedForwardStep )
ReverseStep 	::= 	( ( ReverseAxis ( NodeTest ) ) | AbbreviatedReverseStep )
AbbreviatedForwardStep 	::= 	( <Dot> | ( <At> NameTest ) | NodeTest )
AbbreviatedReverseStep 	::= 	<DotDot>
Predicates 		::= 	( ( ( <Lbrack> Expr <Rbrack> ) ) )*
NumericLiteral 	::= 	( <IntegerLiteral> | <DecimalLiteral> | <DoubleLiteral> )
Literal 		::= 	( NumericLiteral | <StringLiteral> )
ParenthesizedExpr 	::= 	<Lpar> ( ExprSequence )? <Rpar>
FunctionCall 	::= 	<QNameLpar> ( Expr ( <Comma> Expr )* )? <Rpar>
SchemaContext 	::= 	<InContext> SchemaGlobalContext ( <Slash> SchemaContextStep )*
SchemaGlobalContext 	::= 	( <QName> | <TypeQName> )
SchemaContextStep 	::= 	<QName>
SingleType 		::= 	AtomicType ( <QMark> )?
SequenceType 	::= 	( ( ItemType OccurrenceIndicator ) | <Empty> )
ItemType 		::= 	( ( ( <ElementType> | <AttributeType> ) ( ElemOrAttrType )? ) | <Node> | <ProcessingInstruction> | <Comment> | <Text> | ( <Document> ) | <Item> | AtomicType | <Untyped> | <AtomicValue> )
ElemOrAttrType 	::= 	( ( <QName> ( SchemaType | ( SchemaContext )? ) ) | SchemaType )
SchemaType 		::= 	<OfType> <QName>
AtomicType 		::= 	<QName>
OccurrenceIndicator 	::= 	( ( <Star> | <Multiply> | <Plus> | <QMark> ) )?
